"""Anything 3D"""

from collections import namedtuple

XYZ = namedtuple(
    "XYZ",
    ["x", "y", "z"],
)


def all_90_rotations():
    """Return a list of all the possible 90 degree rotations generated using:
    Roll -> 3x Turn CW -> Roll -> 3x Turn CCW -> Roll -> 3x Turn CW -> Roll -> 3x Turn CCW -> Roll -> 3x Turn CW -> Roll -> 3x Turn CCW
    """

    # roll (x-invariant)
    # z
    # |_y
    roll_map = {
        "+y": "+z",
        "+z": "-y",
        "-y": "-z",
        "-z": "+y",
    }

    # ccw (y-invariant)
    # z
    # |_x
    ccw_map = {
        "+x": "+z",
        "+z": "-x",
        "-x": "-z",
        "-z": "+x",
    }

    # cw (y-invariant)
    # z
    # |_x
    cw_map = {
        "+z": "+x",
        "+x": "-z",
        "-z": "-x",
        "-x": "+z",
    }

    def roll(cur):
        return tuple([roll_map.get(o, o) for o in cur])

    def ccw(cur):
        return tuple([ccw_map.get(o, o) for o in cur])

    def cw(cur):
        return tuple([cw_map.get(o, o) for o in cur])

    all_24 = []
    cur = ("+x", "+y", "+z")
    for roll_index in range(6):
        cur = roll(cur)
        all_24.append(cur)
        for _ in range(3):
            cur = cw(cur) if roll_index % 2 == 0 else ccw(cur)
            all_24.append(cur)

    return all_24


def rotate_a_point(p: XYZ, rot):
    """Given a rotation as listed in all_90_rotations, rotate about origin"""
    new_point = [0] * 3
    for i in range(3):
        v = p[i]
        to_axis = rot[i]
        if to_axis[0] == "-":
            v = -v
        to_axis = to_axis[1]
        to_axis = "xyz".index(to_axis)
        new_point[to_axis] = v
    return tuple(new_point)


def test_rotation():
    """Take the diagonal / across the front face"""
    dg = ((-1, -1, -1), (-1, 1, 1))
    a, b = dg
    dgs = set()
    for r in all_90_rotations():
        a2 = rotate_a_point(a, r)
        b2 = rotate_a_point(b, r)
        dg2 = (a2, b2)
        print(dg2)
        dgs.add(dg2)

    print(len(dgs))


def get_grid_limits(point_tuples):
    """Return the limits of the data"""
    if not point_tuples:
        return 0, 0, 0, 0, 0, 0
    min_x = min(point[0] for point in point_tuples)
    max_x = max(point[0] for point in point_tuples)
    min_y = min(point[1] for point in point_tuples)
    max_y = max(point[1] for point in point_tuples)
    min_z = min(point[2] for point in point_tuples)
    max_z = max(point[2] for point in point_tuples)

    return min_x, min_y, min_z, max_x, max_y, max_z


def octahedron_manhattan_planes(p, d):
    """Return 8 planes (4 pairs of 2 opposite parallel faces) of an octahedron
    defined by a centre and manhattan distance.

    The 4 dimensions are generated by +/- of the x,y values
    similar to the notion of rotating a 2D diamond into a square.

    Each entry is a 4-tuple of the lower and upper manhattan distances
    from the origin.

    We initially generate them as if z=0, then we simply add on the z-value
    to get the final manhattan distances from the origin

    Use the pythonic standard on expressing the upper limit as exclusive"""
    x, y, z = p
    pp = (
        x + y,
        x - y,
        y - x,
        -x - y,
    )
    pp = [p + z for p in pp]
    return tuple((p - d, p + d + 1) for p in pp)


def octaplanes_to_point_set(octaplanes):
    """Assuming octaplanes have been created as in octahedron_manhattan_planes
    this is inverse translation"""
    possible_points = set()
    for i0 in range(octaplanes[0][0], octaplanes[0][1]):
        for i1 in range(octaplanes[1][0], octaplanes[1][1]):
            for i2 in range(octaplanes[2][0], octaplanes[2][1]):
                for i3 in range(octaplanes[3][0], octaplanes[3][1]):
                    x = i0 - i2
                    y = i0 - i1
                    z = i0 + i3
                    if x % 2 == 0 and y % 2 == 0 and z % 2 == 0:

                        x = x // 2
                        y = y // 2
                        z = z // 2

                        d0 = x + y + z
                        d1 = x - y + z
                        d2 = y - x + z
                        d3 = z - x - y
                        if (
                            octaplanes[0][0] <= d0 < octaplanes[0][1]
                            and octaplanes[1][0] <= d1 < octaplanes[1][1]
                            and octaplanes[2][0] <= d2 < octaplanes[2][1]
                            and octaplanes[3][0] <= d3 < octaplanes[3][1]
                        ):
                            # x,y,z are legitimate
                            possible_points.add((x, y, z))
    return possible_points
